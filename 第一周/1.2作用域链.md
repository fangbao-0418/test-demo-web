### 1.2如何区分私有变量和全局变量
* 1.1 在全局作用域下声明(预解释的时候)的变量叫去**全局变量**
* 1.2 在私有作用域中声明的变量和函数的形参都是**私有变量**
* 1.3 在私有作用域中 我们代码执行的时候遇到一个变量 首先我们要确定是否是私有变量 如果是私有变量那么和外面的没有任何关系-->如果不是私有的则往当前作用域的上级作用域进行查找 如果上级也没有 继续查找一直找到window为止----这种机制叫做**作用域链**
* 2.1 当函数的执行的时候(直接目的:让函数体中代码执行)会形成一个新的私有的作用域--> 如果有形参先给形参赋值 进行私有作用域中的预解释 私有作用域中的代码从上到下执行
* 2.2 函数形成了一个新的作用域保护了里面的私有私有变量不受外界干扰(外面的修改不了里面的 私有的修改不了外面的)这种保护机制**闭包**
### 1.3全局作用域下var带不带的区别
* 区别:带var的可以进行预解释 所以在赋值的前面执行不会报错 -- 而不带var的是不能进行预解释的在前面执行会报错
* 关系:num=12 ==> 相当于给Window增加了一个num的属性名属性值是12；var num=12 ==> 相当于给全局作用域下变量声明了一个全局变量num 但是不仅如此他也相当于给window增加一个属性名 属性值12
* 如果一直变量一直查找到Window时候还是没有找到这个值 那么对于这种情况我们分为两种情况：1.1获取值 --就会报错 1.2我们设置值:total=100 ==> 相当于给window增加了一个total的属性
* 一般js代码上面报错下面就不会执行了 但是我们有一种机制try catch 即使报错也会向下执行
### 1.4预解释中的变态机制
* 预解释是一种毫无节操的机制
* in:'num' in window 用来判断num是否为window这个对象的一个属性(num必须是字符串)；
* 1.预解释的时候无论条件是否成立 都要把带var的进行提前声明(例子)
* *匿名函数之函数表达式*:把函数定义的部分当做一个值赋值给我们的变量或者是元素的某一个事件 ==>针对这种情况建议使用此种方式定义函数(因为这样函数只能在下面执行 找错的时候去上面找就好)
* 2.预解释的时候只对等号左边的进行预解释右边的不预解释
* **自执行函数**：定义和执行一起完成了;
* 3.自执行函数的function在全局作用域下不进行预解释，当代码执行到这个位置的时候定义和执行一起完成
* 4.函数中return下面的代码虽然不再执行了但是会进行预解释；return后面跟着的都是我们返回的值所以不进行预解释
* 5.在预解释的时候如果名字已经声明过了不需要再重新声明 但是需要重新赋值
* 预解释理解
  `fn5();function fn5() {console.log(1);}fn5();var fn5 = 10;fn5();function fn5() {console.log(2);}fn5();`
### 1.5如何查找上级作用域
* 当前函数是在哪个作用域下定义的 那么他的上级作用域就是谁 跟函数在哪执行的没有任何关系 *如何查找*
### 1.6内存释放和作用域销毁的研究
* **堆内存**:对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存 堆内存是一个地址 如果外面的变量知道了这个地址 我们就说这个内存被占用了 不能销毁
* **内存释放/垃圾回收**：我们想要让堆内存释放/销毁 只需要把所有引用它的变量赋值为null如果当前的堆内存没有任何东西被占用了 那么游览器就会在空闲的时候把他销毁
* **栈内存**:代码执行的环境 window 和函数执行时候形成的私有作用域
* **全局作用局**:只有当页面关闭的时候全局作用域才会销毁
* **私有作用域**:(只要函数执行会产生私有作用域)一般情况下函数执行会形成一个新的私有作用域，当私有作用域中的代码执行完毕后 就会自己销毁 ==> 但是还是存在特殊情况:当前私有作用域中的部分内容被作用域以外的东西占用了那么当前这个作用域就不能销毁了 1)函数执行返回了一个引用数据类型值，并且在函数的外面被一个其他的东西接收了，这种情况下一般形成的私有作用域都不销毁(例子)`function fn() {var num = 100; return function() {num++; console.log(num);}}var f = fn();` 2)在一个私有的作用域中给DOM元素的事件绑定方法一般情况下我们的私有作用域都不销毁`var oDiv = document.getElementsByClassName('div1')[0];~function(){oDiv.onclick = function () {}} ();` 3)fn返回的函数没有被其他东西占用但是不立即销毁 当返回的值执行完成 游览器会把把他销毁`function fn() {var num = 100; return function() {}};fn()()`
* 通过DOM方法获取到的元素或者元素集合数据类型都是对象数据类型
* 作用域练习题
* ++i和i++区别：i++先拿i的值进行计算 然后i本身再加1; ++i是先i本身加1后再计算`var i = 5; console.log(2 + (i++) + (++i) + (++i) + (i++));`
### 1.8 this关键字
* js中this代表当前行为执行的主体
* this是谁和函数在哪定义的和在哪执行的都没有任何的关系-->如何区分执行主体是谁即this
* 1.函数执行，首先看函数名之前有没有"."有的话点前面是谁this就是谁 没有的话this就是window
* 2.自执行函数中的this永远是window
* 3.给元素的某一个事件绑定方法 当事件触发的时候执行对应的方法 方法中的this是当前的元素