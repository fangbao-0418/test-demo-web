## ajax
- async javascript and xml  异步的js和xml*xml中使用的标签都是自己扩展的*
- 客户端js中的方法 运行在客户端的游览器中 用来向服务器端发送请求及传递给服务器端数据
### xml
- 利用自己扩展的有规则的标记来存储相关的数据
## ajax四步
### 创建一个ajax对象(IE6以下不兼容)
- `var xhr = new XMLHttpRequest;`
### 发送前的基本信息配置(请求方式，接口地址,同步还是异步,username,userpass)
- 最后两个参数一般是特定用户才会用到
- true异步false同步；默认是true
- `xhr.open("get","/data.json",false);`
### 给onreadystatechange绑定事件 只要状态改变就会触发方法
- *xhr.readyState* ajax请求状态码 代表ajax当前处理的进度
- 0: unsent 当前的请求还没有发送
- 1：opened url地址已经打开(发送前的参数配置已经完成)
- 2：headers_received 响应头信息已经接受
- 3：loading 主要返回的内容正在服务器端进行准备处理
- 4：done 响应的主体内容已经成功返回到客户端
- *xhr.status* http网络状态码 描述服务器端响应内容的状态
- 200 or ^2\d{2} 代表响应的内容已经成功返回了
- 301 永久重定向/永久转移 www.360buy.com
- 302 临时重定向/临时转移 服务器负载均衡 服务器集群
- 304 本次获得的内容是读的缓存区中的数据
- 400 客户端给服务器端的参数出现错误
- 401 无权限访问
- 404 客户端访问的地址不存在
- 500 未知的服务器错误
- 503 服务器超负荷了(没有做负载均衡就是503做了就是302)
- `xhr.onreadystatechange = function(){`
    `if(xhr.readyState===4 && /^2\d{2}$/.test(xhr.status)){`
      `var val = xhr.responseText`
    `}`
  `};`
  ### 发送请求
  - 参数是请求主体(没有参数一般写null)
- `xhr.send(null);`
### 惰性思想
- 单例模式 用flag 惰性思想 能够执行一次就搞定的绝对不对执行第二次
- ajax兼容结合惰性思想 封装 **代码库1**
### ajax中HTTP请求方式
- GET 一般从服务器获取内容；传递内容时：一般使用url问号传参的方式
`xhr.open("get","/data?name='gyr'&age=12")`
- POST 一般向服务器推送数据；传递内容时：一般使用请求主体的方式*json格式字符串*
`xhr.open("post","/data")；`
`xhr.send('{name:'gyr',age:12}')`
- PUT 一般用于向服务器上增加资源文件(如*上传图片功能*)
- DELETE 一般用于从服务器上删除资源文件
- HEAD 一般用于只获取服务器的响应头信息
#### get与post区别
- get请求传递给服务器的内容存在大小的限制，而post没有限制(因为游览器对于url的长度有限制：谷歌8kb/火狐7kb/IE2kb)
- 缓存问题：get请求会出现缓存，这个缓存不一定是304(304是我们自己处理的)；post没有缓存 ==>加随机数解决
`xhr.open("get","/data?name='gyr'&age=12&_="+ Math.random())`
- 安全问题：一般get不安全而post相对安全些
## ajax同步异步
- js属于单线程的，所以最好使用异步编程
#### 定时器都是异步编程
- 定时器的时间设置为0也不立马执行需要等待一段时间，谷歌是5~6 IE10~13
- 我们定时器设定1000ms执行，也不一定到了时间就立即执行，因为线程要是被占用就不会输出
- 多个定时器，如果上一个功能执行完这几个定时器都到时间了，js会先输入时间短的，因为任务队列会把时间短的排在前面
#### 事件绑定都是异步编程的
#### 回调函数也可以理解为异步编程
#### ajax里面可以使用异步编程
- ajax中的同步：当ajax任务开始的时候(send之后ajax的任务才开始)，一直需要到readyState===4的时候任务才结束，此时才能处理其他的事情
- ajax中的异步：当ajax任务开始的时候，不需要等到readyState===4的时候，我们就能继续做其他的任务，并且只有当其他的任务完成后，我们再看是否是4，到达4的时候再做一些其他的操作 **代码获取服务器时间2**
### 总结知识点(涉及2个封装)
- *ajax四部曲*
- *第一步* 创建ajax对象兼容写法封装
- *第二步* http请求方式method:get post put delete head; ajax同步异步
- *第三步* jax请求码状态0 1 2 3 4；http网络状态码200 301 302 304 400 401 404 500 503
- *ajax请求兼容写法封装* 传参options;初始化参数_default;for in循环接收参数后重新赋值;url方式get请求加随机数;状态2的时候回调函数;状态是4的时候回调函数;回调函数两种写法;JSON.parse兼容写法;
- *第四部* get请求传null;post此处放请求主体
- xhr.setRequestHeader("gyr":"2017");//设置请求头信息 要在open之后
- xhr.timeout = "1000";//设置ajax请求的超时时间
- var time = xhr.getResponseHeader("Date");//获取服务器的响应头信息 只能状态是2的时候 获取服务器时间 解决时间差
