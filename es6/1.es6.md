### let
1. 形成块级作用域 ==>
* 不会污染全局对象
* for循环的i可以保留
* 闭包新写法 {}
2. 重复定义会报错
3. 不存在变量预解释
### 常量 const
1. 常量一旦赋值就不能再重新赋值了`const name = 'gyr'; name = 'fb';` 但是值可以改变`const names = ['gyr'];names.push('fb');console.log(names);`
2. 不同的块级作用域可以重复定义`const A = '0';{const A = '1';console.log(A)} console.log(A);`
### 解构
1. 数组解构
* 解析数组 `var [name,age] = ['gyr',8];console.log(name,age);//gyr 8`
* 嵌套赋值 `var [x,[y],z] = [1,[3,4,5],8,9];console.log(x,y,z);//1,3,8``var [x,[y,z],h] = [1,[2,3,4]];console.log(x,y,z,h);//1,2,3,undefined`
* 省略赋值 `{let [, , x] = [1,2,3];console.log(x);}//3`
2. 解构对象
* 原理:真正被赋值的是属性值即变量不是属性名`let {foo : baz } = {foo : 'aa',baz: 'bb'};console.log(baz);//aa console.log(foo);//报错`
3. 数组和对象都可以设置默认值
* `let [a = "a", b = "b", c =new Error('C必须指定')] = [1, , 3];
   console.log(a, b, c);`
* `function ajax (options) {
       var method = options.method || "get";
       var data = options.data || {};
       //.....
   }
   ajax({
        method: "post",
        data: {"name": "zfpx"}
    });`
### 模板字符串
1. 反引号里面放模板字符串 用${}调去变量 `var name = 'zfpx',age = 8;let desc = `${name} is ${age} old!`;` 所有模板字符串的空格和换行，都是被保留的
2. 带标签的模板字符串 `var name = 'zfpx',age = 8;
                  function desc(strings,...values){
                      console.log(strings,values);
                  }
                  desc`${name} is ${age} old!`;`
3. 新方法
* includes()：返回布尔值，表示是否找到了参数字符串。
* startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部
* endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
`var s = 'zfpx';
 s.startsWith('z') // true
 s.endsWith('x') // true
 s.includes('p') // true`
* 第二个参数，表示开始搜索的位置
`var s = 'zfpx';
 console.log(s.startsWith('p',2)); // true
 console.log(s.endsWith('f',2)); // true
 console.log(s.includes('f',2)); // false`
* endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束
### repeat
1. repeat方法返回一个新字符串，表示将原字符串重复n次。
### 函数
1. 用展开操作符...进项展开 ==>代替apply ==> 类数组转成数组
* `let print = function(a,b,c){
         console.log(a,b,c);
     };
     print([1,2,3]);
     print.apply(null,[1,2,3]);
     print(...[1,2,3]);`
  `function A(){console.log(...argumrnts)} A(1,2,3)`
* 代替 concat
`var arr1 = [1, 3];
     var arr2 = [3, 5];
     var arr3 = arr1.concat(arr2);
     var arr4 = [...arr1, ...arr2];
     console.log(arr3,arr4);`
2. ...剩余操作符
`let rest = function(a,...b){
     console.log(a,b);
 }
 rest(1,2,3);`
3. 解构参数
`let rest = function(a,...b){
     console.log(a,b);
 }
 rest(1,2,3);`
4. 函数名字
* ECMAScript 6 给函数添加了一个name属性
`var desc = function descname(){}
 console.log(desc.name);`
5. 箭头函数

